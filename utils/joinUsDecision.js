const { 
  MEMBER_ROLE_NAME, 
  MEMBER_ROLE_ID, 
  PENDING_ROLE_ID, 
  GUEST_ROLE_ID, 
  VISITOR_ROLE_NAME,
  TEAM_SEARCH_CHANNEL_ID,
  CLIPS_CHANNEL_ID,
  SCREENSHOTS_CHANNEL_ID,
  BALANCE_CHANGES_CHANNEL_ID,
  MEMES_CHANNEL_ID,
  TICKET_CLOSE_DELAY_MS,
} = require("../config/channels");

const UNVERIFIED_ROLE_NAME = "Unverified";
const APPLICANT_ROLE_NAME = "Applicant";

async function removePendingRole(guild, member) {
  const pendingRole = guild.roles.cache.get(PENDING_ROLE_ID);
  if (pendingRole && member.roles.cache.has(pendingRole.id)) {
    await member.roles.remove(pendingRole).catch(() => {});
  }
}

async function cleanupJoinUsMessages(guild, ticketChannel) {
  const messages = await ticketChannel.messages.fetch({ limit: 50 }).catch(() => null);
  if (!messages) return;

  const metaMsg = messages.find((m) => m.content.startsWith("META_JOINUS:"));
  if (!metaMsg) return;

  const [, joinChannelId, userMsgId, botMsgId] = metaMsg.content.split(":");
  const joinChannel = await guild.channels.fetch(joinChannelId).catch(() => null);
  if (!joinChannel || !joinChannel.isTextBased()) return;

  const userMsg = await joinChannel.messages.fetch(userMsgId).catch(() => null);
  if (userMsg) await userMsg.delete().catch(() => {});

  const botMsg = await joinChannel.messages.fetch(botMsgId).catch(() => null);
  if (botMsg) await botMsg.delete().catch(() => {});
}

async function applyAcceptRoles(guild, member) {
  const result = {
    addedGuest: false,
    addedMember: false,
    removedApplicant: false,
    removedUnverified: false,
  };

  // Add Guest role
  try {
    if (GUEST_ROLE_ID) {
      const guestRole = guild.roles.cache.get(GUEST_ROLE_ID);
      if (guestRole && !member.roles.cache.has(guestRole.id)) {
        await member.roles.add(guestRole);
        result.addedGuest = true;
      }
    }
  } catch (err) {
    console.warn(`⚠️ Failed to add Guest role to ${member.user?.tag}: ${err.message}`);
  }

  // Add Member role
  try {
    const memberRole = MEMBER_ROLE_ID
      ? guild.roles.cache.get(MEMBER_ROLE_ID)
      : guild.roles.cache.find((r) => r.name === MEMBER_ROLE_NAME);
    if (memberRole && !member.roles.cache.has(memberRole.id)) {
      await member.roles.add(memberRole);
      result.addedMember = true;
    }
  } catch (err) {
    console.warn(`⚠️ Failed to add Member role to ${member.user?.tag}: ${err.message}`);
  }

  // Remove Applicant role
  try {
    const applicantRole = guild.roles.cache.find((r) => r.name === APPLICANT_ROLE_NAME);
    if (applicantRole && member.roles.cache.has(applicantRole.id)) {
      await member.roles.remove(applicantRole);
      result.removedApplicant = true;
    }
  } catch (err) {
    console.warn(`⚠️ Failed to remove Applicant role from ${member.user?.tag}: ${err.message}`);
  }

  // Remove Unverified role
  try {
    const unverifiedRole = guild.roles.cache.find((r) => r.name === UNVERIFIED_ROLE_NAME);
    if (unverifiedRole && member.roles.cache.has(unverifiedRole.id)) {
      await member.roles.remove(unverifiedRole);
      result.removedUnverified = true;
    }
  } catch (err) {
    console.warn(`⚠️ Failed to remove Unverified role from ${member.user?.tag}: ${err.message}`);
  }

  return result;
}

async function applyDeclineRoles(guild, member) {
  const result = {
    removedApplicant: false,
    removedUnverified: false,
    addedVisitor: false,
  };

  try {
    const applicantRole = guild.roles.cache.find((r) => r.name === APPLICANT_ROLE_NAME);
    if (applicantRole && member.roles.cache.has(applicantRole.id)) {
      await member.roles.remove(applicantRole);
      result.removedApplicant = true;
    }
  } catch (err) {
    console.warn(`⚠️ Failed to remove Applicant role from ${member.user?.tag}: ${err.message}`);
  }

  try {
    // Remove Unverified role so declined users can explore limited channels
    const unverifiedRole = guild.roles.cache.find((r) => r.name === UNVERIFIED_ROLE_NAME);
    if (unverifiedRole && member.roles.cache.has(unverifiedRole.id)) {
      await member.roles.remove(unverifiedRole);
      result.removedUnverified = true;
    }
  } catch (err) {
    console.warn(`⚠️ Failed to remove Unverified role from ${member.user?.tag}: ${err.message}`);
  }

  try {
    // Add Visitor role to give access only to specific channels (team-search, clips, screenshots, etc.)
    const visitorRole = guild.roles.cache.find((r) => r.name === VISITOR_ROLE_NAME);
    if (visitorRole && !member.roles.cache.has(visitorRole.id)) {
      await member.roles.add(visitorRole);
      result.addedVisitor = true;
    }
  } catch (err) {
    console.warn(`⚠️ Failed to add Visitor role to ${member.user?.tag}: ${err.message}`);
  }

  return result;
}

async function closeTicketSoon(ticketChannel) {
  setTimeout(() => {
    ticketChannel.delete().catch(() => {});
  }, TICKET_CLOSE_DELAY_MS);
}

async function runJoinUsTicketDecision({
  guild,
  ticketChannel,
  decisionMessage = null,
  userId,
  decision, // "accept" | "deny"
  moderatorLabel,
  reason = null,
}) {
  const member = await guild.members.fetch(userId).catch(() => null);
  if (!member) {
    if (decisionMessage) await decisionMessage.edit({ components: [] }).catch(() => {});
    await closeTicketSoon(ticketChannel);
    return { ok: false, error: "Utilisateur introuvable (a quitté le serveur ?)" };
  }

  if (decisionMessage) await decisionMessage.edit({ components: [] }).catch(() => {});

  await removePendingRole(guild, member);
  await cleanupJoinUsMessages(guild, ticketChannel);

  if (decision === "accept") {
    const applyResult = await applyAcceptRoles(guild, member);
    const roleChangeOk = applyResult.addedGuest || applyResult.addedMember;

    await ticketChannel
      .send(
        roleChangeOk
          ? `✅ Candidature **ACCEPTÉE** par ${moderatorLabel}${reason ? `\nRaison : ${reason}` : ""}.`
          : `✅ Candidature **ACCEPTÉE** par ${moderatorLabel}, mais je n'ai pas pu changer les rôles.\n⚠️ Assure-toi que le rôle du bot est au-dessus de Guest/Member et a la permission 'Gérer les rôles'.`,
      )
      .catch(() => {});

    await member
      .send(
        "✅ Ta candidature a été **acceptée** !\n" +
          "Un membre du staff ༒ Blood Ascend ༒ te contactera **en jeu plus tard aujourd'hui** pour t'intégrer.",
      )
      .catch(() => {});

    await closeTicketSoon(ticketChannel);
    return roleChangeOk ? { ok: true } : { ok: false, error: "Permissions insuffisantes pour changer les rôles lors de l'acceptation." };
  }

  if (decision === "deny") {
    await applyDeclineRoles(guild, member);

    await ticketChannel
      .send(
        `❌ Candidature **REFUSÉE** par ${moderatorLabel}${reason ? `\nRaison : ${reason}` : ""}.`,
      )
      .catch(() => {});

    const teamSearchMention = `<#${TEAM_SEARCH_CHANNEL_ID}>`;
    const clipsMention = `<#${CLIPS_CHANNEL_ID}>`;
    const screenshotsMention = `<#${SCREENSHOTS_CHANNEL_ID}>`;
    const balanceChangesMention = `<#${BALANCE_CHANGES_CHANNEL_ID}>`;
    const memesMention = `<#${MEMES_CHANNEL_ID}>`;

    const declineMessage =
      "Malheureusement ta candidature a été refusée, " +
      "Si tu veux un ami ou une équipe tu peux contacter nos membres individuellement ou aller dans notre\n\n" +
      `${teamSearchMention}\n\n` +
      "pour trouver une équipe, mais on ne peut malheureusement pas t'intégrer au syndicat. " +
      "Ta candidature a été refusée pour les raisons suivantes : " +
      `${reason ? reason : "(aucune raison fournie)"}. ` +
      "Quand tout sera réglé, n'hésite pas à nous recontacter et on sera ravi de te reconsidérer.\n" +
      "En attendant, explore le serveur :\n\n" +
      `${clipsMention}\n` +
      `${screenshotsMention}\n` +
      `${balanceChangesMention}\n` +
      `${memesMention}`;

    await member.send(declineMessage).catch(() => {});

    await closeTicketSoon(ticketChannel);
    return { ok: true };
  }

  return { ok: false, error: "Décision invalide" };
}

module.exports = {
  runJoinUsTicketDecision,
};

